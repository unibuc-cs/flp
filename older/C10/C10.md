---
author:
- |
  Traian-Florin Șerbănuță\
  Andrei Sipoș
subtitle: C10
title: \[
---

::: frame
:::

# Programare Logică Logica Clauzelor Horn

::: frame
Program în Prolog = mulțime de predicate

Un exemplu de [program în Prolog]{.alert} din cursul trecut:

::: columns
::: column
.5

    father(peter,meg). 
    father(peter,stewie).

    mother(lois,meg). 
    mother(lois,stewie).

    griffin(peter).
    griffin(lois).

    griffin(X) :- father(Y,X),  griffin(Y).
:::

::: column
.3 **Predicate:**\
father/2\
mother/2\
griffin/1
:::
:::
:::

::: frame
Spre logica din spatele Prologului

Pentru a putea modela universul programului, fixăm un
alfabet/signatură/vocabular:

-   o mulțime $\mathbf{R}$ de simboluri de relații/predicate

-   o mulțime $\mathbf{F}$ de simboluri de operații/funcții

-   o funcție aritate $ar: \mathbf{F} \cup \mathbf{R} \to \mathbb{N}$

-   Fie $\mathbf{C}\subseteq \mathbf{F}$ mulțimea simbolurilor de
    operații de aritate $0$, numite și simboluri de constante.

Notăm cu $\mathbf{R}_n$/$\mathbf{F}_n$ mulțimea simbolurilor de
relații/operații de aritate $n$. Observație: $\mathbf{F}_0 = C$

**Exemplu.**

-   $\mathbf{R} = \mathbf{R}_1 \uplus \mathbf{R}_2$, unde
    $\mathbf{R}_1 = \{P\}$ și $\mathbf{R}_2 = \{R\}$

-   $\mathbf{F} = \mathbf{F}_0 \uplus \mathbf{F}_2$, unde
    $\mathbf{F}_0 = C = \{c\}$ și $\mathbf{F}_2 = \{f\}$
:::

::: frame
Sintaxa Prolog

-   Sintaxa Prolog nu face diferență între simboluri de operații și
    simboluri de predicate!

-   Dar este important când ne uităm la teoria corespunzătoare
    programului în logică să facem această distincție.

-   În sintaxa Prolog

    -   termenii compuși sunt predicate: `father(peter, meg)`

    -   operatorii sunt funcții: `+, *, mod`
:::

::: frame
Termeni

Fixăm o mulțime numărabilă de variabile $V$.

Definim termenii inductiv astfel:

-   orice variabilă este un termen

-   orice simbol de constantă este un termen

-   dacă $f\in \mathbf{F}_n$, $n > 0$ și $t_1,\ldots,t_n$ sunt termeni,
    atunci $f(t_1,\ldots,t_n)$ este termen.

**Exemple:** $c,\ x_1,\ f(x_1,c),\ f(f(x_2,x_2),c)$\
unde $c \in \mathbf{C}$ reprezintă o constantă, $x_1,x_2 \in V$ sunt
variabile, iar $f \in \mathbf{F}_2$ reprezintă un simbol de funcție de
aritate 2.
:::

::: frame
Formule atomice

Formulele atomice sunt definite astfel:

::: center
dacă $R\in \mathbf{R}_0$, atunci $R$ este formulă atomică

dacă $R\in \mathbf{R}_n$, $n > 0$ și $t_1,\ldots,t_n$ sunt termeni,\
atunci $R(t_1,\ldots,t_n)$ este formulă atomică.
:::

**Exemple:** $P(f(x_1,c)),\ R(c,x_2)$\
unde $c \in \mathbf C$, $x_1,x_2 \in V$, $f \in \mathbf{F}_2$,
$P \in \mathbf{R}_1$, iar $R \in \mathbf{R}_2$.
:::

::: frame
Formulele logicii de ordinul I

Definim formulele astfel:

-   orice formulă atomică este o formulă

-   dacă $\varphi$ este o formulă, atunci $\neg \varphi$ este o formulă

-   dacă $\varphi$ și $\psi$ sunt formule, atunci $\varphi \vee \psi$,
    $\varphi \wedge \psi$, $\varphi \to \psi$ sunt formule

-   dacă $\varphi$ este o formulă și $x$ este o variabilă, atunci
    $\forall x\, \varphi$, $\exists x\,\varphi$ sunt formule

**Exemplu:**
$$P(f(x_1,c)),\quad P(x_1) \vee P(c), \quad \forall x_1\, P(x_1),  \quad \forall x_2\, R(x_2,x_1)$$
unde $c \in \mathbf{C}$, $x_1,x_2 \in V$, $f \in \mathbf{F}_2$,
$P \in \mathbf{R}_1$, iar $R \in \mathbf{R}_2$.
:::

::: frame
Literali

Un literal este o formulă atomică sau negația unei formule atomice.

O formulă este în formă normală conjunctivă (FNC) dacă este o conjuncție
de disjuncții de literali.

**Exemplu:**
$(P(f(x_1,c)) \vee R(c,x_2)) \ \wedge \ \neg R(x_1,x_2)\ \wedge\ (R(x_1,x_1) \vee \neg P(c))$\
unde $c \in \mathbf{C}$, $x_1,x_2 \in V$, $f \in \mathbf{F}_2$,
$P \in \mathbf{R}_1$, iar $R\in\mathbf{R}_2$.
:::

::: frame
Clauze

-   O clauză este o disjuncție de literali.

-   Dacă $L_1,\ldots, L_n$ sunt literali atunci vom reprezenta clauza
    $L_1\vee\ldots\vee L_n$ ca mulțimea $\{L_1,\ldots, L_n\}$

    ::: center
    clauză = mulțime de literali
    :::

-   O clauză $C$ este trivială dacă conține un literal și complementul
    lui.

-   Când $n=0$ obținem clauza vidă, care se notează $\Box$.
:::

::: frame
Clauze Putem reprezenta o clauză prin mulțimea
$$\{\neg Q_1,\ldots, \neg Q_n, P_1,\ldots,  P_k\}$$ unde $n,k\geq 0$ și
$Q_1,\ldots, Q_n,P_1,\ldots, P_k$ sunt formule atomice.

Formula corespunzătoare este
$$\forall x_1\ldots \forall x_m (\neg Q_1\vee\ldots \vee \neg Q_n\vee  P_1\vee \ldots\vee P_k)$$
unde $x_1,\ldots, x_m$ sunt toate variabilele care apar în clauză

Echivalent, putem scrie
$$\forall x_1\ldots \forall x_m(Q_1\wedge \ldots \wedge Q_n \to P_1\vee \ldots\vee  P_k)$$

Presupunem cuantificarea universală a clauzelor implicită:
$$Q_1\wedge \ldots \wedge Q_n \to P_1\vee \ldots\vee  P_k$$
:::

::: frame
Clauze program definite

-   Clauză $Q_1\wedge \ldots \wedge Q_n \to P_1\vee \ldots\vee  P_k$\
    unde $n,k\geq 0$ și $Q_1,\ldots, Q_n,P_1,\ldots, P_k$ sunt formule
    atomice.

-   Dacă $k=1$, atunci avem o clauză program definită:

    -   cazul $n>0:$ $Q_1\wedge \ldots\wedge  Q_n\to P$

    -   cazul $n=0:$ $\top\to P$ (clauză unitate, fapt)\
        $\top$ este simbol pentru o formula mereu adevărată

-    Program logic definit = mulțime finită de clauze definite
:::

::: frame
Clauze Horn

-   Clauză $Q_1\wedge \ldots \wedge Q_n \to P_1\vee \ldots\vee  P_k$\
    unde $n,k\geq 0$ și $Q_1,\ldots, Q_n,P_1,\ldots, P_k$ sunt formule
    atomice.

-   Dacă $k=0$, atunci avem o clauză scop definită (țintă, întrebare):

    ::: center
    $Q_1\wedge\ldots\wedge Q_n\to \bot$\
    $\bot$ este simbol pentru o formula mereu falsă
    :::

    Vom scrie o clauza scop definită ca $Q_1, \ldots, Q_n$.

-   În plus, dacă $n=k=0$, atunci avem clauza vidă $\Box$

::: center
Clauză Horn = clauză program definită sau clauză scop ($k\leq 1$)
:::

::: center
Limbajul PROLOG are la bază logica clauzelor Horn.
:::
:::

::: frame
Clauze Horn

::: center
Clauza Horn = clauză program definită sau clauză scop ($k\leq 1$)
:::

-   Clauză $Q_1\wedge \ldots \wedge Q_n \to P_1\vee \ldots\vee  P_k$\
    unde $n,k\geq 0$ și $Q_1,\ldots, Q_n,P_1,\ldots, P_k$ sunt formule
    atomice.

-   Fie $x_1, \ldots, x_m$ toate variabilele care apar într-o clauza
    scop $Q_1,\ldots, Q_n$. Atunci avem echivalența

    $$\forall x_1\ldots \forall x_m (\neg Q_1\vee\ldots \vee \neg Q_n) 
    \equiv \neg \exists x_1\ldots \exists x_m (Q_1\wedge \ldots \wedge  Q_n)$$

::: center
Negația unei \"întrebări\" în PROLOG este clauză scop.
:::
:::

::: frame
Programare logica

-    Logica clauzelor Horn: un fragment al logicii de ordinul I în care
    singurele formule admise sunt clauze Horn

    -    formule atomice: $P(t_1,\ldots,t_n)$

    -    $Q_1\wedge \ldots \wedge Q_n \to P$

        unde toate $Q_i,P$ sunt formule atomice, $\top$ sau $\bot$

-    Problema programării logice: reprezentăm cunoștințele ca o mulțime
    de clauze definite $KB$ și suntem interesați să aflăm răspunsul la o
    întrebare de forma $Q_1\wedge\ldots \wedge Q_n$, unde toate $Q_i$
    sunt formule atomice

    ::: center
    $KB \models Q_1\wedge\ldots\wedge Q_n$
    :::

    -   Variabilele din $KB$ sunt cuantificate universal.

    -   Variabilele din $Q_1, \ldots,  Q_n$ sunt cuantificate
        existențial.
:::

::: frame
Un exemplu

Fie următoarele clauze definite:

$father(jon,ken)$.

$father(ken,liz)$.

$father(X,Y) \to ancestor(X,Y)$

$daugther(X,Y) \to ancestor(Y,X)$

$ancestor(X,Y) \wedge ancestor(Y,Z) \to ancestor(X,Z)$

Putem pune întrebările:

-    $ancestor(jon,liz)$?

-    $ancestor(ken,Z)$?\
    (există $Z$ astfel încât $ancestor(ken,Z)$)
:::

::: frame
Sistem de deducție pentru logica clauzelor Horn

Pentru un program logic definit $KB$ avem

-    Axiome: orice clauză din $KB$

-    Regula de deducție *backchain*:
    $$\infer{\theta(Q)}{\theta(Q_1)\quad \theta(Q_2) \quad \ldots \quad \theta(Q_n) \quad (Q_1 \wedge Q_2 \wedge \ldots \wedge Q_n \to P)}$$
    unde $Q_1 \wedge Q_2 \wedge \ldots \wedge Q_n \to P \in KB$, iar
    $\theta$ cmgu pentru $Q$ și $P$.

Regula *backchain* conduce la un sistem de deducție complet:

::: center
Pentru o mulțime de clauze $KB$ și o țintă $Q$,\
dacă $KB \models Q$,\
atunci există o derivare a lui $Q$ folosind regula *backchain*.
:::
:::

::: frame
Cum răspundem la întrebări

Pentru o țintă $Q$, trebuie să găsim o clauză din $KB$

::: center
$Q_1 \wedge \ldots \wedge Q_n \to P$,
:::

și un unificator $\theta$ pentru $Q$ și $P$.

În continuare vom verifica $\theta(Q_1),\ldots,\theta(Q_n)$.

**Exemplu.** Pentru ținta $${\color{IntensColor} ancestor(ken,Z)},$$
putem folosi clauză
$${\color{IntensColor} father(X,Y) \to ancestor(X,Y)}$$ cu unificatorul
$${\color{IntensColor} \{ X \mapsto ken, Y \mapsto Z\} }$$ pentru a
obține o nouă țintă $${\color{IntensColor} father(ken,Z) }.$$
:::

::: frame
Sistem de deducție

Rergula backchain
$$\infer{\theta(Q)}{\theta(Q_1)\quad \theta(Q_2) \quad \ldots \quad \theta(Q_n) \quad (Q_1 \wedge Q_2 \wedge \ldots \wedge Q_n \to P)}$$
unde $Q_1 \wedge Q_2 \wedge \ldots \wedge Q_n \to P \in KB$, iar
$\theta$ este cgu pentru $Q$ și $P$.

**Exemplu.** Presupunem că în KB avem:

$father(ken,liz)$.

$father(X,Y) \to ancestor(X,Y)$

$$\infer{{\color{IntensColor} ancestor(ken,Z)}}{\infer{{\color{IntensColor} father(ken,Z)}}{{father(ken,liz)}} \quad father(X,Y) \to ancestor(X,Y)}$$
:::

::: frame
Puncte de decizie în programarea logica Având doar această regulă, care
sunt punctele de decizie în căutare?

-    Ce clauză să alegem.

    -   Pot fi mai multe clauze a căror parte dreaptă se potrivește cu o
        țintă.

    -   Aceasta este o alegere de tip **SAU**: este suficient ca oricare
        din variante să reușească.

-    Ordinea în care rezolvăm noile ținte.

    -   Aceasta este o alegere de tip **ȘI:** trebuie arătate toate
        țintele noi.

    -   Ordinea în care le rezolvăm poate afecta găsirea unei derivări,
        depinzând de strategia de căutare folosită.
:::

::: frame
Strategia de căutare din Prolog

Strategia de căutare din Prolog este de tip *depth-first*

-    de sus în jos

    -   pentru alegerile de tip **SAU**

    -   alege clauzele în ordinea în care apar în program

-    de la stânga la dreapta

    -   pentru alegerile de tip **ȘI**

    -   alege noile ținte în ordinea în care apar în clauza aleasă
:::

::: frame
Regula backchain și rezoluția SLD

-   Regula *backchain* este implementată în programarea logică prin
    rezoluția SLD (Selected, Linear, Definite).

-   Prolog are la bază rezoluția SLD.
:::

::: frame
Rezoluția SLD

Fie $KB$ o mulțime de clauze definite.

::: center
SLD
:::

unde

-    $Q\vee\neg P_1\vee\cdots\vee \neg P_m$ este o clauză definită din
    $KB$

-   în care toate variabilele au fost redenumite cu variabile noi

-    $\theta$ este cmgu pentru $Q_i$ și $Q$
:::

::: frame
Rezoluția SLD - exemplu

`father(eddard,sansa).`\
`father(eddard,jonSnow).`\
`stark(eddard).`\
`stark(catelyn).`\
`stark(X)``\ `{=latex}`:-``\ `{=latex}`father(Y,X),`\
`stark(Y).`

`?- stark(jonSnow)`

::: center
SLD
:::

-    $Q\vee\neg P_1\vee\cdots\vee \neg P_m$ este o clauză definită din
    $KB$

-   variabilele din $Q\vee\neg P_1\vee\cdots\vee \neg P_m$ și $Q_i$ se
    redenumesc

-    $\theta$ este cmgu pentru $Q_i$ și $Q$.
:::

::: frame
Rezoluția SLD - exemplu

$father(eddard,sansa)$\
$father(eddard,jonSnow)$\
$stark(eddard)$\
$stark(catelyn)$\
$stark(X)\vee\neg father(Y,X)\vee\neg stark(Y)$

$$\displaystyle\frac{\onslide<1->{{\color{IntensColor} \neg stark(jonSnow)}}}
{\onslide<2->{{\color{IntensColor} \neg father(Y,jonSnow)\vee \neg stark(Y)}}}$$

::: center
SLD
:::

-    $Q\vee\neg P_1\vee\cdots\vee \neg P_m$ este o clauză definită din
    $KB$

-   variabilele din $Q\vee\neg P_1\vee\cdots\vee \neg P_m$ și $Q_i$ se
    redenumesc

-    $\theta$ este cmgu pentru $Q_i$ și $Q$.
:::

::: frame
Rezoluția SLD - exemplu

$father(eddard,sansa)$\
$father(eddard,jonSnow)$\
$stark(eddard)$\
$stark(catelyn)$\
$stark(X)\vee\neg father(Y,X)\vee\neg stark(Y)$

$$\displaystyle\frac{{{\color{IntensColor} \neg stark(jonSnow)}}}
{{{\color{IntensColor} \neg father(Y,jonSnow)\vee \neg stark(Y)}}}$$

$$\displaystyle\frac
{{{\color{IntensColor} \neg father(Y,jonSnow)}\vee \neg stark(Y)}} {{ \neg stark(eddard)}}$$

$$\displaystyle\frac {{\color{IntensColor}  \neg stark(eddard)}}{\Box}$$

::: center
SLD
:::

-    $Q\vee\neg P_1\vee\cdots\vee \neg P_m$ este o clauză definită din
    $KB$

-   variabilele din $Q\vee\neg P_1\vee\cdots\vee \neg P_m$ și $Q_i$ se
    redenumesc

-    $\theta$ este cmgu pentru $Q_i$ și $Q$.
:::

::: frame
Rezoluția SLD

Fie $KB$ o mulțime de clauze definite și $Q_1 \wedge \ldots \wedge Q_m$
o întrebare, unde $Q_i$ sunt formule atomice.

-    O derivare din $KB$ prin rezoluție SLD este o secvență

    ::: center
    $G_0:= \neg Q_1 \vee \ldots \vee \neg Q_m$,$G_1$,$\ldots$,$G_k$,
    $\ldots$
    :::

    în care $G_{i+1}$ se obține din $G_i$ prin regula SLD.

-   Dacă există un $k$ cu $G_k=\Box$ (clauza vidă), atunci derivarea se
    numește SLD-respingere.

**Teoremă.** Sunt echivalente:

1.  există o SLD-respingere a lui $Q_1 \wedge \ldots \wedge Q_m$ din
    $KB$,

2.   $KB\models Q_1\wedge\cdots\wedge Q_m$.
:::

::: frame
Rezoluția SLD - arbori de căutare Arbori SLD

-   Presupunem că avem o mulțime de clauze definite $KB$ și o țintă
    $G_0 = \neg Q_1 \vee \ldots \vee \neg Q_m$

-   Construim un arbore de căutare ( arbore SLD) astfel:

    -   Fiecare nod al arborelui este o țintă (posibil vidă)

    -   Rădăcina este $G_0$

    -   Dacă arborele are un nod $G_i$, iar $G_{i+1}$ se obține din
        $G_i$ folosind regula SLD folosind o clauză $C_i \in KB$, atunci
        nodul $G_i$ are copilul $G_{i+1}$.\
        Muchia dintre $G_i$ și $G_{i+1}$ este etichetată cu $C_i$.

-   Dacă un arbore SLD cu rădăcina $G_0$ are o frunză $\Box$ (clauza
    vidă), atunci există o SLD-respingere a lui $G_0$ din $KB$.
:::

::: frame
Rezoluția SLD - arbori de căutare

**Exemplu.**

Fie $KB$ următoarea mulțime de clauze definite:

1.   $grandfather(X,Z):-father(X,Y), parent(Y,Z)$

2.   $parent(X,Y):-father(X,Y)$

3.   $parent(X,Y):-mother(X,Y)$

4.   $father(ken,diana)$

5.   $mother(diana,brian)$

Găsiți o respingere din $KB$ pentru

::: center
$?- grandfather(ken,Y)$
:::
:::

::: frame
Rezoluția SLD - arbori de căutare

**Exemplu.**

Fie $KB$ următoarea mulțime de clauze definite:

1.   $grandfather(X,Z) \vee \neg father(X,Y) \vee \neg parent(Y,Z)$

2.   $parent(X,Y) \vee \neg father(X,Y)$

3.   $parent(X,Y) \vee \neg mother(X,Y)$

4.   $father(ken,diana)$

5.   $mother(diana,brian)$

Găsiți o respingere din $KB$ pentru

::: center
$\neg grandfather(ken,Y)$
:::
:::

::: frame
Rezoluția SLD - arbori de căutare

**Exemplu.**

1.  $grandfather(X,Z) \vee \neg father(X,Y)\vee \neg parent(Y,Z)$

2.  $parent(X,Y)\vee \neg father(X,Y)$

3.  $parent(X,Y)\vee \neg mother(X,Y)$

4.  $father(ken,diana)$

5.  $mother(diana,brian)$

<figure>

</figure>
:::

::: frame
Limbajul Prolog

-   Am arătat că sistemul de inferență din spatele Prolog-ului este
    complet.

    -   Dacă o întrebare este consecință logică a unei mulțimi de
        clauze, atunci există o derivare a întrebării.

-   Totuși, [strategia de căutate din Prolog este incompletă!]{.alert}

    -   Chiar dacă o întrebare este consecință logică a unei mulțimi de
        clauze, Prolog nu găsește mereu o derivare a întrebării.
:::

::: frame
Limbajul Prolog - exemplu

`warmerClimate``\ `{=latex}`:-``\ `{=latex}`albedoDecrease.`\
`warmerClimate``\ `{=latex}`:-``\ `{=latex}`carbonIncrease.`\
`iceMelts``\ `{=latex}`:-``\ `{=latex}`warmerClimate.`\
`albedoDecrease``\ `{=latex}`:-``\ `{=latex}`iceMelts.`\
`carbonIncrease.`\
`?-``\ `{=latex}`iceMelts.`\
[`!``\ `{=latex}`Out``\ `{=latex}`of``\ `{=latex}`local``\ `{=latex}`stack`]{.alert}
:::

::: frame
Limbajul Prolog - exemplu

[`warmerClimate`]{.alert}`\ `{=latex}`:-``\ `{=latex}[`albedoDecrease.`]{.alert}\
`warmerClimate``\ `{=latex}`:-``\ `{=latex}`carbonIncrease.`\
[`iceMelts`]{.alert}`\ `{=latex}`:-``\ `{=latex}[`warmerClimate`]{.alert}`.`\
[`albedoDecrease`]{.alert}`\ `{=latex}`:-``\ `{=latex}[`iceMelts.`]{.alert}\
`carbonIncrease.`\
`?-``\ `{=latex}`iceMelts.`\
[`!``\ `{=latex}`Out``\ `{=latex}`of``\ `{=latex}`local``\ `{=latex}`stack`]{.alert}
:::

::: frame
Limbajul Prolog - exemplu

Totuși, există o derivare a lui $iceMelts$ în sistemul de deducție din
clauzele:

::: center
  ------------------ ------- ------------------
    $albedoDecrease$  $\to$  $warmerClimate$
    $carbonIncrease$  $\to$  $warmerClimate$
     $warmerClimate$  $\to$  $iceMelts$
          $iceMelts$  $\to$  $albedoDecrease$
              $\top$  $\to$  $carbonIncrease$
  ------------------ ------- ------------------

$\inferrule
    {\inferrule
    {carbonInc. \\ carbonInc. \to warmerClim.}
    {warmerClim.} \\ warmerClim. \to iceMelts}
    {iceMelts}$
:::
:::

::: frame
Rezoluția SLD - arbori de căutare

**Exercițiu** Desenați arborele SLD pentru programul Prolog de mai jos
și ținta\
`?- p(X,X).`

  -------------------------------- ----------------------
  `1. p(X,Y) :- q(X,Z), r(Z,Y).`   `7. s(X) :- t(X,a).`
  `2. p(X,X) :- s(X).`             `8. s(X) :- t(X,b).`
  `3. q(X,b).`                     `9. s(X) :- t(X,X).`
  `4. q(b,a).`                     `10. t(a,b).`
  `5. q(X,a) :- r(a,X).`           `11. t(b,a).`
  `6. r(b,a).`                     
  -------------------------------- ----------------------
:::

::: frame
Rezoluția SLD - arbori de căutare

  ------------------------------------------ -------------------------- ------------------------ ---------------
  `1. p(X,Y) :- q(X,Z), r(Z,Y).`             `4. q(b,a).`               `7. s(X) :- t(X,a).`     `10. t(a,b).`
  `2. p(X,X) :- s(X).`                       `5. q(X,a) :- r(a,X).`     `8. s(X) :- t(X,b).`     `11. t(b,a).`
  `3. q(X,b).`                               `6. r(b,a).`               `9. s(X) :- t(X,X).`     
                                                                                                 
  $p(X,Y) \vee \neg q(X,Z)\vee\neg r(Z,Y)$   $q(b,a)$                   $s(X) \vee\neg t(X,a)$   $t(a,b)$
  $p(X,X) \vee\neg s(X)$                     $q(X,a) \vee\neg r(a,X)$   $s(X) \vee\neg t(X,b)$   $t(b,a)$
  $q(X,b)$                                   $r(b,a)$                   $s(X) \vee\neg t(X,X)$   
  ------------------------------------------ -------------------------- ------------------------ ---------------
:::

::: frame
**Pe data viitoare!**
:::
